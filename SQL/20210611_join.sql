-- 2021.06.11

-- JOIN

-- CROSS JOIN
-- 스키마의 합 : 집합의 곱 연산과 같다

SELECT *
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;

-- 이름이 SCOTT인 사람의 부서명을 출력해봅시다.
-- 출력해야하는 컬럼을 가지는 테이블을 확인해보자
-- 이름 : EMP, 부서명 : DEPT

SELECT E.ENAME, D.DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND E.ENAME = 'SCOTT';

-- SELF JOIN : 자기 자신을 조인(참조)
-- EMP -> MGR 컬럼이 EMP.EMPNO 참조
SELECT E.EMPNO, E.ENAME, E.MGR, M.ENAME
FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO(+);

-- 동등 비교가 아닌 크다 작다와 같은 비교로 조인의 조건을 작성

SELECT * FROM SALGRADE;

SELECT E.ENAME, E.SAL, S.GRADE, S.LOSAL, S.HISAL
FROM EMP E, SALGRADE S
--WHERE E.SAL >= S.LOSAL AND E.SAL <= S.HISAL
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
ORDER BY E.ENAME;

SELECT * FROM ORDERS;
SELECT * FROM CUSTOMER;
SELECT * FROM BOOK;

SELECT O.ORDERID, C.NAME, B.BOOKNAME
FROM ORDERS O, CUSTOMER C, BOOK B
WHERE O.CUSTID = C.CUSTID AND O.BOOKID = B.BOOKID
ORDER BY O.ORDERID;

-- ANSI -> INNER JOIN
-- ORACLE EQUI JOIN

SELECT E.ENAME, D.DNAME, D.DEPTNO
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
WHERE E.ENAME = 'SCOTT';

-- ON 절을 생략하고 -> USING을 이용하면 조건식을 간략하게 생략할 수 있다.
SELECT E.ENAME, D.DNAME, DEPTNO
FROM EMP E INNER JOIN DEPT D
USING (DEPTNO)
WHERE E.ENAME = 'SCOTT';

-- NATURAL JOIN
SELECT *
FROM EMP NATURAL JOIN DEPT;

-- OUTER JOIN
SELECT E.EMPNO, E.ENAME, E.MGR, M.ENAME
FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO(+);

-- [LEFT | RIGHT | FULL] OUTER JOIN
SELECT *
FROM EMP E LEFT OUTER JOIN EMP M
ON E.MGR = M.EMPNO;

-- 회원별 구매 내역 출력
SELECT C.NAME, COUNT(O.ORDERID) AS "구매 횟수", NVL(ROUND(AVG(O.SALEPRICE)), 0) AS "평균 구매액"
FROM ORDERS O, CUSTOMER C
WHERE O.CUSTID(+) = C.CUSTID
GROUP BY C.NAME
ORDER BY C.NAME;

SELECT C.NAME, O.ORDERID
FROM ORDERS O, CUSTOMER C
WHERE O.CUSTID(+) = C.CUSTID;

SELECT C.NAME, O.ORDERID
FROM ORDERS O RIGHT OUTER JOIN CUSTOMER C
ON O.CUSTID = C.CUSTID;